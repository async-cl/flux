<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1252" />
      <title>Cloudshift Application Framework</title>
      <link href="/reset.css" rel="stylesheet" type="text/css" />
      <link href="/content.css" rel="stylesheet" type="text/css" />
      <link href="/syntax/styles/shCore.css" rel="stylesheet" type="text/css" />
      <link href="/syntax/styles/shThemeEclipse.css" rel="stylesheet" type="text/css" />
    </head>

    <body>
      <div id="ifc">
<p></p><h1>Async I/O for haXe (Wip)</h1><p></p><p> Here  are  some  thoughts  on  a  haxe  async  api,  comments  welcome.    </p><p> With  the  arrival  of  async  platforms,  like  Node.js,  haXe  requires  an  abstract  API     for  dealing  with  async  I/O.  This  document  does  not  deal  with  the  entire  Node.js     api,  just  that  which  can  map  basic  async  I/O  to  haXe.    </p><p> haXe  blocking  I/O  is  at  it's  core  is  readByte().  On  top  of  this  is     implemented  readString(),  readDouble  etc,  for  each  platform.  However  in  an  async     solution  one  doesn't  really  want  to  be  getting  into  tight  loops  with  this    </p><p><pre>readByte(function(b) { });</pre>   </p><p> So,  mirroring  the  current  model  is  not  performant,  however  we  would  like  to     present  something  as  close  to  the  current  model  as  possible.    </p><p> Both  haXe  and  Node.js  have  very  good  buffer  support,  and  one  maps  to  the  other     very  well.  Opinions  are  welcome  here  as  my  experience  is  limited  to  node.js,  but     it  seems  to  me  that  buffering  async  reads/writes  in  chunks  so  that  further     in-memory  reads  of  Bytes,  i.e.  readByte():Int,  is  generally  a  good     strategy.    </p><p></p><h1>Readers</h1><p></p><p> haxe.io.ByteInput  offers  a  means  of  separating  the  reading  of  a  buffer  from     it's  interpretation,  so  I  propose  two  new  classes  for  Async  reading,    </p><p></p><table><thead><tr><th> Class               </th><th> Description                                                       </th></tr></thead><tbody><tr><td>---------------------+-------------------------------------------------------------------</td></tr><tr><td> AsyncPositionReader </td><td> A buffer of a given size is returned from the specified position. </td></tr><tr><td> AsyncStreamReader   </td><td> A buffer of a given size is returned repeatedly until EOF         </td></tr></tbody></table><p></p><p><pre>



interface AsyncPositionReader implements AsyncBufferedReader {
    function read(bufSize:Int,cb:Int-&gt;BytesInput-&gt;Void):Void;
    function seek(pos:Int):Void;
    function tell():Int;
    function close():Void;
}

interface AsyncStreamReader implements AsyncBufferedReader {
    function onBytes(cb:Int-&gt;BytesInput-&gt;Void):Void;
    function onEnd():Void;
    function close():Void;
}

</pre></p><p></p><p></p><p></p><h1>New haxe.sys.io.AsyncFile</h1><p></p><p></p><p> To  access  a  BufferedInput,    </p><p><pre>

var pr = AsyncFile.position(path,bufSize);
pr.seek(2000);
pr.read(function(err,input) {
  if (err != null) {
     // process
     
  }
});
</pre></p><p></p><p></p><p><pre>

var pr = AsyncFile.stream(path,bufSize);
pr.read(function(err,input) {
  if (err != null) {
     // process
     
  }
});
</pre></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p><pre>

var br = AsyncFile.read(path,bufSize);
br.read(1,function(input) {

});
</pre></p><p></p><p></p><p> If  you're    </p><p></p><p></p><h1>Buffer Mapping</h1><p></p><p> This  provides  an  idea  of  a  node.js->haxe  buffer  mapping.    </p><p><pre>/*
 * Copyright (c) 2005-2008, The haXe Project Contributors
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE HAXE PROJECT CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE HAXE PROJECT CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */
package haxe.io;

class Bytes {

	public var length(default,null) : Int;
	var b : BytesData;

	function new(length,b) {
		this.length = length;
		this.b = b;
	}

	public inline function get( pos : Int ) : Int {
		#if neko
		return untyped __dollar__sget(b,pos);
		#elseif flash9
		return b[pos];
		#elseif php
		return untyped __call__("ord", b[pos]);
		#elseif cpp
		return untyped b[pos];
		#else
		return b[pos];
		#end
	}

	public inline function set( pos : Int, v : Int ) : Void {
		#if neko
		untyped __dollar__sset(b,pos,v);
		#elseif flash9
		b[pos] = v;
		#elseif php
		b[pos] = untyped __call__("chr", v);
		#elseif cpp
		untyped b[pos] = v;
		#else
		b[pos] = v &amp; 0xFF;
		#end
	}

	public function blit( pos : Int, src : Bytes, srcpos : Int, len : Int ) : Void {
		#if !neko
		if( pos &lt; 0 || srcpos &lt; 0 || len &lt; 0 || pos + len &gt; length || srcpos + len &gt; src.length ) throw Error.OutsideBounds;
		#end
		#if neko
		try untyped __dollar__sblit(b,pos,src.b,srcpos,len) catch( e : Dynamic ) throw Error.OutsideBounds;
		#elseif php
		// TODO: test me
		b = untyped __php__("substr($this-&gt;b, 0, $pos) . substr($src-&gt;b, $srcpos, $len) . substr($this-&gt;b, $pos+$len)"); //__call__("substr", b, 0, pos)+__call__("substr", src.b, srcpos, len)+__call__("substr", b, pos+len);
		#elseif flash9
		b.position = pos;
		if( len &gt; 0 ) b.writeBytes(src.b,srcpos,len);
		#else
		var b1 = b;
		var b2 = src.b;
		if( b1 == b2 &amp;&amp; pos &gt; srcpos ) {
			var i = len;
			while( i &gt; 0 ) {
				i--;
				b1[i + pos] = b2[i + srcpos];
			}
			return;
		}
		for( i in 0...len )
			b1[i+pos] = b2[i+srcpos];
		#end
	}

	public function sub( pos : Int, len : Int ) : Bytes {
		#if !neko
		if( pos &lt; 0 || len &lt; 0 || pos + len &gt; length ) throw Error.OutsideBounds;
		#end
		#if neko
		return try new Bytes(len,untyped __dollar__ssub(b,pos,len)) catch( e : Dynamic ) throw Error.OutsideBounds;
		#elseif flash9
		b.position = pos;
		var b2 = new flash.utils.ByteArray();
		b.readBytes(b2,0,len);
		return new Bytes(len,b2);
		#elseif php
		// TODO: test me
		return new Bytes(len, untyped __call__("substr", b, pos, len));
		#else
		return new Bytes(len,b.slice(pos,pos+len));
		#end
	}

	public function compare( other : Bytes ) : Int {
		#if neko
		return untyped __dollar__compare(b,other.b);
		#elseif flash9
		var len = (length &lt; other.length) ? length : other.length;
		var b1 = b;
		var b2 = other.b;
		b1.position = 0;
		b2.position = 0;
		for( i in 0...len&gt;&gt;2 )
			if( b1.readUnsignedInt() != b2.readUnsignedInt() ) {
				b1.position -= 4;
				b2.position -= 4;
				return b1.readUnsignedInt() - b2.readUnsignedInt();
			}
		for( i in 0...len &amp; 3 )
			if( b1.readUnsignedByte() != b2.readUnsignedByte() )
				return b1[b1.position-1] - b2[b2.position-1];
		return length - other.length;
		#elseif php
		return untyped __php__("$this-&gt;b &lt; $other-&gt;b ? -1 : ($this-&gt;b == $other-&gt;b ? 0 : 1)");
		#else
		var b1 = b;
		var b2 = other.b;
		var len = (length &lt; other.length) ? length : other.length;
		for( i in 0...len )
			if( b1[i] != b2[i] )
				#if cpp
				return untyped b1[i] - untyped b2[i];
				#else
				return b1[i] - b2[i];
				#end
		return length - other.length;
		#end
	}

	public function readString( pos : Int, len : Int ) : String {
		#if !neko
		if( pos &lt; 0 || len &lt; 0 || pos + len &gt; length ) throw Error.OutsideBounds;
		#end
		#if neko
		return try new String(untyped __dollar__ssub(b,pos,len)) catch( e : Dynamic ) throw Error.OutsideBounds;
		#elseif flash9
		b.position = pos;
		return b.readUTFBytes(len);
		#elseif php
		// TODO: test me
		return untyped __call__("substr", b, pos, len);
//		return untyped __call__("call_user_func_array", "pack", __call__("array_merge", __call__("array", "C*"), __call__("array_slice", b.�a, pos, len)));
		#elseif cpp
		var result:String="";
		untyped __global__.__hxcpp_string_of_bytes(b,result,pos,len);
		return result;
		#else
		var s = "";
		var b = b;
		var fcc = String.fromCharCode;
		var i = pos;
		var max = pos+len;
		// utf8-encode
		while( i &lt; max ) {
			var c = b[i++];
			if( c &lt; 0x80 ) {
				if( c == 0 ) break;
				s += fcc(c);
			} else if( c &lt; 0xE0 )
				s += fcc( ((c &amp; 0x3F) &lt;&lt; 6) | (b[i++] &amp; 0x7F) );
			else if( c &lt; 0xF0 ) {
				var c2 = b[i++];
				s += fcc( ((c &amp; 0x1F) &lt;&lt; 12) | ((c2 &amp; 0x7F) &lt;&lt; 6) | (b[i++] &amp; 0x7F) );
			} else {
				var c2 = b[i++];
				var c3 = b[i++];
				s += fcc( ((c &amp; 0x0F) &lt;&lt; 18) | ((c2 &amp; 0x7F) &lt;&lt; 12) | ((c3 &lt;&lt; 6) &amp; 0x7F) | (b[i++] &amp; 0x7F) );
			}
		}
		return s;
		#end
	}

	public function toString() : String {
		#if neko
		return new String(untyped __dollar__ssub(b,0,length));
		#elseif flash9
		b.position = 0;
		return b.readUTFBytes(length);
		#elseif php
		// TODO: test me
		return cast b;
//		return untyped __call__("call_user_func_array", "pack", __call__("array_merge", __call__("array", "C*"), b.�a));
		#else
		return readString(0,length);
		#end
	}

	public function toHex() : String {
		var s = new StringBuf();
		var chars = [];
		var str = "0123456789abcdef";
		for( i in 0...str.length )
			chars.push(str.charCodeAt(i));
		for( i in 0...length ) {
			var c = get(i);
			s.addChar(chars[c &gt;&gt; 4]);
			s.addChar(chars[c &amp; 15]);
		}
		return s.toString();
	}

	public inline function getData() : BytesData {
		return b;
	}

	public static function alloc( length : Int ) : Bytes {
		#if neko
		return new Bytes(length,untyped __dollar__smake(length));
		#elseif flash9
		var b = new flash.utils.ByteArray();
		b.length = length;
		return new Bytes(length,b);
		#elseif php
		// TODO: test me
		return new Bytes(length, untyped __call__("str_repeat", __call__("chr", 0), length));
		/*
		if(length &gt; 0)
			return new Bytes(length, untyped __call__("new _hx_array", __call__("array_fill", 0, length, 0)));
		else
			return new Bytes(0, untyped __call__("new _hx_array", __call__("array")));
		*/
		#elseif cpp
		var a = new BytesData();
		if (length&gt;0) a[length-1] = untyped 0;
		return new Bytes(length,a);
		#else
		var a = new Array();
		for( i in 0...length )
			a.push(0);
		return new Bytes(length,a);
		#end
	}

	public static function ofString( s : String ) : Bytes {
		#if neko
		return new Bytes(s.length,untyped __dollar__ssub(s.__s,0,s.length));
		#elseif flash9
		var b = new flash.utils.ByteArray();
		b.writeUTFBytes(s);
		return new Bytes(b.length,b);
		#elseif php
		return new Bytes(untyped __call__("strlen", s), cast s);
//		return ofData(untyped __call__("new _hx_array", __call__("array_values", __call__("unpack", "C*",  s))));
		#elseif cpp
		var a = new BytesData();
		untyped __global__.__hxcpp_bytes_of_string(a,s);
		return new Bytes(a.length,a);
		#else
		var a = new Array();
		// utf8-decode
		for( i in 0...s.length ) {
			var c : Int = StringTools.fastCodeAt(s,i);
			if( c &lt;= 0x7F )
				a.push(c);
			else if( c &lt;= 0x7FF ) {
				a.push( 0xC0 | (c &gt;&gt; 6) );
				a.push( 0x80 | (c &amp; 63) );
			} else if( c &lt;= 0xFFFF ) {
				a.push( 0xE0 | (c &gt;&gt; 12) );
				a.push( 0x80 | ((c &gt;&gt; 6) &amp; 63) );
				a.push( 0x80 | (c &amp; 63) );
			} else {
				a.push( 0xF0 | (c &gt;&gt; 18) );
				a.push( 0x80 | ((c &gt;&gt; 12) &amp; 63) );
				a.push( 0x80 | ((c &gt;&gt; 6) &amp; 63) );
				a.push( 0x80 | (c &amp; 63) );
			}
		}
		return new Bytes(a.length,a);
		#end
	}

	public static function ofData( b : BytesData ) {
		#if flash9
		return new Bytes(b.length,b);
		#elseif neko
		return new Bytes(untyped __dollar__ssize(b),b);
		#elseif php
		return new Bytes(untyped __call__("strlen", b), b);
		#else
		return new Bytes(b.length,b);
		#end
	}

}
</pre></p><p></p><p></p><p></div>
</body>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shCore.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shBrushAS3.js"></script>    

    
    <script type="text/javascript">
      $(function() {
      $("table").addClass("gridtable");
      $("pre").addClass("brush: as3;");
      SyntaxHighlighter.highlight();
      });
    </script>
    
</html>
