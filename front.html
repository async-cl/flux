<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html"/>
      <title>Flux Framework</title>
      <link href="/reset.css" rel="stylesheet" type="text/css" />
      <link href="/content.css" rel="stylesheet" type="text/css" />
      <link href="/syntax/styles/shCore.css" rel="stylesheet" type="text/css" />
      <link href="/syntax/styles/shThemeEclipse.css" rel="stylesheet" type="text/css" />
    </head>

    <body>
      <div id="ifc">
<p></p><p></p><p></p><h1>Flux, a haXe Stack for Node.js</h1><p></p><p></p><h2>Formerly know as cloudshift</h2><p></p><p></p><p> Flux  is  a <a target="_blank" href="http://www.nodejs.org">Node.js</a> framework  written  in  the <a target="_blank" href="http://www.haxe.org">haXe</a> language.  Flux     is  UI  agnostic,  the  emphasis  is  on  server  side  plumbing  and  infrastructure  for     common  requirements.    </p><p> Why  haXe  for  Node.js  applications?  In  short,  a  single  typed  language  for  all     tiers.  A  fuller  exposition  of  haXe  and  Node.js  benefits  is <a href="/whyhaxenode.html">here</a> .  Why  is  typing     important?  Read  this  from  the  trenches  ...    </p><p><a target="_blank" href="http://blog.meloncard.com/post/12175941935/how-one-missing-var-ruined-our-launch">How One Missing Var Ruined Our Launch</a> ...  any  questions?    </p><p> Flux  is  self  contained  and  complete,  it  includes:    </p><p></p><ul><li> Core  functionality  of  Outcomes,  Futures,  Observables  and  mixins.  Read <a href="/manual/coremixin.html">manual</a> . <li> Caching  web  server.  Read <a href="/manual/http.html">manual</a> . <li> Typed  RPC  using  haXe  remoting.  Read <a href="/manual/remotes.html">manual</a> . <li> Session  management.  Read <a href="/manual/session.html">manual</a> . <li> Seemless  haXe  workers  (sub  process)  for  Node.js  server.  Read <a href="/manual/workers.html">manual</a> . <li> Embedded  Sqlite  (Redis  coming  soon)  haXe  object  storage  with  indexable  and  relatable  objects.  Read <a href="/manual/data.html">manual</a> . <li> Push  messaging  (web  sockets  coming  soon)  client/server  and  server/server.  Read <a href="/manual/channel.html">manual</a> . <li> Bitcoin  Api.  Read <a href="/manual/bitcoin.html">manual</a> . </ul><p> All  the  components  use  the  same  Core  functionality  to  structure  their     interactions.    </p><p> Even  if  I  can't  convince  you  on  Flux,  please  do  look  into  the  use  of  my    <a target="_blank" href="http://www.github.com/flux/hx-node">haXe typedefs</a> for  Node.js  -  haXe/Node.js  is  a  winning  combination.  Check  out     haxenode.org  for  introductory  material.    </p><p></p><h2>Status</h2><p> Right  now,  I'm  documenting  and  finalising  the  api  for  external  consumption.  I     anticipate  early  2012  for  a  first  cut.    </p><p> All  the  code  is  on <a target="_blank" href="https://github.com/flux">github</a> .    </p><p><a target="_blank" href="http://bingocoin.net">BingoCoin.net</a> is  100%  Flux.  There's  a  technical  exposition    <a href="/bingo.html">here</a> .  Disclaimer:  I'm  not  a  designer  and  it's  in  development.    </p><h1>Why Flux?</h1><p> The  purpose  of  Flux  is  to  provide  easier  development  of  scaleable,  large     code  base  web  applications.    </p><p> Let's  break  that  down:    </p><p></p><h2>Easier</h2><p></p><p></p><ul><li><strong>Deployment</strong> .  With  as  few  external  dependencies  as  possible,  and  removing  the  ones  that  do  exist  as  time  permits,  makes  it  much  easier  to  deploy  and  run  a  Flux  application.  You  can  deploy  a  fully  functioning  server  by  copying  one  .js  file  and  running  it  like  this, <strong>node myserver.js localhost 8082</strong> . </ul><p></p><ul><li><strong>Refactoring</strong> .  One  language  and  set  of  type  definitions  across  all  tiers,  removes  a  class  of  bugs,  and  let's  teams  interact  better. </ul><p></p><ul><li><strong>Marshalling</strong> .  By  consistently  applying  haXe  remoting,  the  flow  of  typed  data  between  tiers  (client/server/subprocess/data/messaging)  is  enhanced  with  a  corresponding  drop  in  bugs.  Flux  provides  haXe  the  server  side  async  remoting. </ul><p></p><ul><li><strong>Data</strong> .  Flux  provides  a  Data  interface  to  store  haXe  object  instances  in  'buckets',  which  are  relatable  and  indexable.  There  are  also  persistent  hashes.  Data  doesn't  prejudice  other  solutions  but  is  available  in  the  box. </ul><p></p><h2>Scaleable</h2><p></p><p> Node.js  is  a  c10K  server  environment,  that  is  10000  concurrent  connections     are  possible  because  it's  an  async  server.  Thus  choosing  Node.js  is  a  good     start  for  'scaleable'.    </p><p> Node.js  is  also  fairly  lightweight  when  compared  against,  e.g.  Java.  A     node.js  instance  may  weigh  in  at  15MB,  rather  than  60MB  for  a  typical  java     instance.  Thus  firing  up  more  nodes  for  specific  purposes  is  very  typical.     Flux  provides  haXe  remoting  between  nodes  and  a  messaging  system,  thus     creating  multi-node  solutions,  and  hence  scaleable  systems  is  part  of  the     fabric  of  Flux.    </p><p> Flux  also  provides  a  seamless  worker  facility  wherein  you  can  start  up     sub  processes  and  communicate  with  them  over  haXe  remoting.    </p><h2>Large Code Base</h2><p></p><p> Static  typing  is,  imo,  the  only  way  to  go  on  a  large  code  base.  It's  easier     to  refactor.  Teams  can  interact  better.  Consistency  can  be  maintained  over     the  entire  project  automatically.     haXe  gives  us  static  typing,  but  also  some  of  the  benefits  of  a  dynamic     language  with  type  inference  and  reflection.  One  of  the  most  underrated     benefits  of  the  haXe  compiler  is  it's  speed.  haXe  can  compile  thousands  of     lines  of  code  in  a  second,  you  can  compile  in  your  edit/compile/run  cycle  as     if  the  compile  wasn't  there.    </p><p> Further,  haXe  provides  a  simple  build  system,  adequate  for  most  purposes     that  allows  the  compilation  of  all  targets,  e.g  server.js  and  client.js,  in     one  go.  Thus  checking  consistency  of  all  tiers  at  once.    </div>
</body>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shCore.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shBrushAS3.js"></script>    

    
    <script type="text/javascript">
      $(function() {
      $("table").addClass("gridtable");
      $("pre").addClass("brush: as3;");
      SyntaxHighlighter.highlight();
      });
    </script>
    
</html>
