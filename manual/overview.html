<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html"/>
      <title>Flux Framework</title>
      <link href="/reset.css" rel="stylesheet" type="text/css" />
      <link href="/content.css" rel="stylesheet" type="text/css" />
      <link href="/syntax/styles/shCore.css" rel="stylesheet" type="text/css" />
      <link href="/syntax/styles/shThemeEclipse.css" rel="stylesheet" type="text/css" />
    </head>

    <body>
      <div id="ifc">
<p></p><h1>Overview</h1><p></p><p> The  Flux  framework  provides  high  level  abstractions  to  the  file  I/O  and     network  services  provided  by  Node.js.  To  achieve  this  Flux  provides  core     library  support  for  async  and  functional  programming,  remoting  and  alternatives     to  threading.    </p><p> Flux  then  builds  upon  these  primitives  to  provide  a  messaging  service,     object  storage  and  an  application  model  that  is  inherently  asynchronous.    </p><p> Flux  is  based  upon  my  raw  Node.js  typedefs,    <a href="http://github.com/cloudshift/hx-node">http://github.com/cloudshift/hx-node</a> which  may  be  dipped  into  at  any  time,     however,  it  tries  to  split  the  raw  api  into  cooperating  modules  that  are  fully     typed  and  follow  Flux  component  model.    </p><p> All  of  this  is  within  the  contraints  of  strong  typing  and  super  fast  compilation     provided  by  haXe  to  provide  a  great  place  for  Node.js  development.    </p><p> To  find  out  what  Flux  is  trying  to  achieve  lets  look  at  the  basics.    </p><p></p><h1>The Node.js Model</h1><p></p><p> Node.js  is  a  single  threaded  async  server  that  requires  the  use  of  callback     functions  for  programming  servers  effectively.  There  are  blocking  I/O  functions     but  you'd  use  them  only  for  command  line  tools.    </p><p> If  you  prefer <pre>y=f(x)</pre> style  I/O  programming  then  read  no  further.    </p><p> If  you're  interested  in  a  functional  style  of  programming  and  how  best  to  deal     with <pre>f(x,function(y) {})</pre> and  make  it  work  for  you  then  continue.    </p><p></p><h2>Why Async Programming?</h2><p></p><p> Async  programming  is  the  single  largest  hurdle  to  cross  if  you're  new  to  it,  but     it  can  be  cleanly  supported  using  a  functional  style  of  programming,  which  in     itself  will  help  reduce  bugs  by  reducing  state,  and  forcing  you  do  deal  with     errors  up  front.    </p><p> The  primary  benefits  of  Node.js  due  to  a  single  thread  and  async  nature  is     scalability.  Nothing  blocks,  so  many  I/O  connections  can  be  satisfied  without     the  cost  of  a  thread  for  each.  Long  running  tasks  are  run  in  sub-process.    </p><p> This  provides  is  great  scalability  per  node  instance  but  there  is  a  more     important  side  effect.  When  you  write  in  async  you  are  writing  for  distributed     computing  by  default.  You  could  move  portions  of  your  code  and  call  it  from     another  node,  and  not  notice  the  difference  -  everything  was  async  to  start  with     so  the  times  to  callback  can  increase  but  you're  program  will  still     function.  This  in  my  opinion  is  the  biggest  benefit.  If  you're  writing  in  async     you're  writing  for  "the  cloud"  and  distributed  systems.    </p><p> Flux  embraces  the  async  programming  model  with  Futures  and  Outcomes  and     adopts  a  functional  style  throughout  the  library    </p><p></p><h2>Single Threaded?</h2><p></p><p> This  is  a  popular  put  down  for  Node.js  antagonists,  as  most  programmers  used  to     a  blocking  style  will  dismiss  without  further  investigation  an  alternative  to     the  'one  true  way'.  However,  long  running  tasks  can  be  dealt  with  effectively     in  sub-process  -  each  of  which  can  be  run  on  separate  cores  (see  the  manual  here     for  further  investigation  of  this  topic).    </p><p> What  is  conveniently  glossed  over  is  a  rather  huge  benefit  of  a  single     thread. <strong>No thread programming</strong> .  No  races,  no  deadlocks,  no  timing     issues.  Programming  for  a  single  thread  is  a  huge  win,  and  removes  an  entire     class  of  bugs.    </p><p></p><h1>Flux Modules</h1><p></p><p> Flux  includes  these  modules  in  the  top  level  package    </p><p></p><table><thead><tr><th> Module  </th><th> Description                                                               </th></tr></thead><tbody><tr><td> Core    </td><td> Option, Either, Outcomes, Observables, Futures, Startables and Stoppables </td></tr><tr><td> Http    </td><td> Http server, add handlers based on regex                                  </td></tr><tr><td> Session </td><td> Add managed session between clients and servers                           </td></tr><tr><td> Sys     </td><td> A higher level interface to Node.fs with Outcomes                         </td></tr><tr><td> Remote  </td><td> Async haXe remotes                                                        </td></tr><tr><td> Workers </td><td> Process data in subprocess with seamless haXe remoting calls              </td></tr><tr><td> Data    </td><td> Store haXe objects in Sqlite, NoSQL style, relate them, index them        </td></tr><tr><td> Channel </td><td> Publish/subscribe push Messaging                                          </td></tr></tbody></table><p> To  use  all  of  them  :    </p><p><pre>

using flux.Core;
import flux.Sys;
import flux.Remote;
import flux.Http;
import flux.Session;
import flux.Workers;
import flux.Data;
import flux.Channel;
</pre></p><p></p><p></p><h2>Programming to Interfaces</h2><p></p><p> Each  top  level  module  contains  enums,  interfaces  and  typedefs  for  the  user.  It     also  provides  factory  functions  to  provide  default  implementations  of  these     interfaces.    </p><p> For  example,  the  Core  module,    </p><p><pre>


using flux.Core;

...

var p:Future&lt;X&gt; = Core.future();

</pre></p><p></p><p></p><p> Future<X>  is  an  interface.  Core.future()  returns  an  implementation.    </p><p> Similarly,    </p><p><pre>


import flux.Http;

...

var p:HttpServer = Http.server();

</pre></p><p></p><p> where  HttpServer  is  an  interface  and  Http.server()  provides  an  implementation.    </p><p> Again,  flux.Http  is  the  controlling  top  level  module  which  contains  the     contract  between  the  user,  and  the  internal  implementation.    </p><p> The  private  implementations  are  contained  in  the  package  of  the  same  name.    </p><p><pre>flux.http;
flux.core;
flux.data;
</pre></p><p></p><p> The  user  however  should  never  really  need  to  access  anything  from  within  the     imlementation  directories  -  unless  there's  a  class  that  requires  to  be     subclassed.  But  generally  speaking  I  will  try  and  use  factories  returning  an     implementation  rather  than  subclass.    </p><p> Thus,  inspection  of  the  top  level  module  should  provide  all  one  needs  to  know     about  the  module  usage.    </p><p></div>
</body>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shCore.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shBrushAS3.js"></script>    

    
    <script type="text/javascript">
      $(function() {
      $("table").addClass("gridtable");
      $("pre").addClass("brush: as3;");
      SyntaxHighlighter.highlight();
      });
    </script>
    
</html>
