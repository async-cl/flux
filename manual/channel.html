<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1252" />
      <title>Cloudshift Application Framework</title>
      <link href="/reset.css" rel="stylesheet" type="text/css" />
      <link href="/content.css" rel="stylesheet" type="text/css" />
      <link href="/syntax/styles/shCore.css" rel="stylesheet" type="text/css" />
      <link href="/syntax/styles/shThemeEclipse.css" rel="stylesheet" type="text/css" />
    </head>

    <body>
      <div id="ifc">
<p></p><h1>Channel</h1><p></p><p><strong>Documentation unfinished</strong>   </p><p> Channel  is  the  Flux  message  service.  Currently  it  supports  push  messaging     over  http,  but  as  you  will  see,  it  has  the  ability  to  support  multiple     transports.  Messages  received  on  either  end  are  fully  typed  and  can  include     classes  and  enums  due  to  haXe  serialization.    </p><p></p><h1>Server Setup</h1><p></p><p> The  Channel  module  uses  the  Http  and  Session  modules.  The  Http  module  provides  the     transportation  of  packets  and  Session  allows  for  the  abilty  to  authorize  or  deny     clients  on  specific  channels.  This  means  that  a  client  must  authenticate  with  the     server  before  being  able  to  use  Channel.    </p><p> Here  is  an  out  of  context  example  of  a  setup  to  provide  a  flavor.    </p><p><pre>

    Http.server()
      .root("www")
      .start({host:"localhost",port:8082})
      .outcome(function(http) {
          Channel.server()
            .addHttpServer(http)
            .addSessionAuth(sessAuth)
            .start({}).outcome(startRooms);
        });    
</pre></p><p></p><p> The  default  implementation  of  Channel  is  a  push  server  thus  an  http  server  is     required.  If  an  Http  server  is  not  supplied  it's  created  for  you.    </p><p> To  use  the  channel  server  and  enable  access  to  channels  based  on  agent     attributes,  a  session  manager  is  required.  flux.Session  is  used  for  this     purpose.  If  a  session  manager  is  not  supplied  one  is  created  for  you.  In  any     event,  you  are  required  to  call  addSessionAuth  with  a  function  that  processes     login,  logout  and  registration  events  from  the  session  manager,  e.g.    </p><p><pre>

  function sessAuth(event:ESessionOp) {
    switch(event) {
    case Login(pkt,reply):
      trace("logging in with "+pkt);
      var lp:LoginPkt = pkt;
      if (nicks.exists(lp.nick)) {
        trace("user exists");
        reply(UserExists);
      } else {
        var sessID = genID();
        nicks.set(lp.nick,sessID);
        trace("userOK");
        reply(UserOk(sessID));  
      }

    case Signup(pkt,reply):
      reply(UserOk(genID()));

    case Logout(sessID,reply):
      trace("got Logout for "+sessID);
      for(n in nicks.keys()) {
        if (nicks.get(n) == sessID) {
          nicks.remove(n);
          //room.fill(System(Leaves(n)));
        }
      }

      reply(UserRemoved);
    }
  }
</pre></p><p></p><p> See  the  Session  module  help  for  more  details.    </p><p> Once  you  have  the  channelServer,  you  can  create  channels  on  it  ...    </p><p><pre>


  enum MsgTypes {
    Chat(nick:String,msg:String);
    System(msg:SysMsg);
  }
...
  public function
  startRooms(cs:ChannelServer) {
    cs.channel("/chat/room").outcome(function(room:Chan&lt;MsgTypes&gt;) {
        room.filter(function(o) {
            switch(o) {
            case Chat(nick,msg):
              return Chat(nick.toUpperCase(),msg);
            default:
            }
            return o;
          });
    
        room.peek(function(pe) {
            switch(pe) {
            case Add(i):
              room.pub(Chat("bot","someone entered"));
            case Del(i):
              room.pub(Chat("bot","someone left"));
            }
          });
      });
  }

</pre></p><p></p><p> Channels  are  created  using  a  channel  ID,  I  use  the  typical  method  of  a     hierarchical  /  notation  but  it's  arbitary.    </p><p> The  idea  is  that  the  channel  "/chat/room"  is  available  on  both  client  and  server     and  can  publish,  subscribe  and  filter  on  both  sides.    </p><p></p><h1>Client Setup</h1><p></p><p> On  the  client,  one  needs  to  get  a  valid  session  from  the  session  manager.  The     clients  pass  some  credentials  to  the  server  using  the  login  method  of  session  -  the     login  packet  is  arbitrary  and  up  to  the  application  to  define,  in  this  case  just     a  nick.  If  all  is  good  a  sessionID  (again  arbitrary)  is  returned  and  this     sessionID  is  then  used  to  create  the  channel  client.    </p><p><pre>

      Session.client().start({}).outcome(function(sess) {
        sess.login(nick).deliver(function(es) {
            switch(es) {
            case UserOk(sessID):
              trace("got sessID:"+sessID);
              Channel.client()
                .start(sessID)
                .outcome(function(client) {
                    _chanClient = client;
                    trace("starting room");
                    startRoom(nick,client);
                  },function(reason) {
                    trace(reason);
                  });
            default:
            }
          });
      });

</pre></p><p></p><p> Once  the  channel  client  is  initialised,  a  more  or  less  symmetric  channel  setup     is  available  ...    </p><p><pre>

  public function
  startRoom(nick:String,client:ChannelClient) {
    client.channel("/chat/room")
      .outcome(function(room) {
          _room = room;
          ChatUi.status("authorized in room");
          ChatUi.setChat(function(msg) {
              trace("should be sending "+msg);
              room.pub(Chat(nick,msg));
            });
          room.sub(function(mt:MsgTypes) {
              switch(mt) {
              case Chat(nick,msg):
                ChatUi.msg(nick,msg);
                case System(smt):
                  ChatUi.systemMsg(smt);
              }
            });
        },function(reason) {
          ChatUi.status("you're not authorised" +reason);
        });
  }

</pre></p><p></p><p></p><h1>Channel Authorization </h1><p></p><p> Not  all  channels  on  a  server  should  be  available  to  all  connecting  clients,  we  need     a  method  of  restricting  access  to  specific  channels.    </p><p> A  channel  authorization  function  may  be  added  to  the  channel  server  before     starting  it  using  the  addChannelAuth  method  ...    </p><p><pre>

   Channel.server()
     .addHttpServer(http)
     .addSessionAuth(sessAuth)
     .addChannelAuth(channelAuth)
     .start({}).outcome(startRooms);

</pre></p><p></p><p> You're  provided  with  the  sessID  of  the  requester,  and  the  channel  they  wish  to     connect  to,  by  providing  the  callback  with  the  either  you  may  approve/deny  the  request.    </p><p><pre>


  function channelAuth(sessID:String,chan:Chan&lt;Dynamic&gt;,cb:Either&lt;String,String&gt;-&gt;Void) {
    if (chan.pid() != "/secret") {
      cb(Right("")); // setup up new connection so it can get next msg too
      //room.fill(System(Arrives(sess.stash(sessID,"nick").get(),nicks.keyArray())));
    } else {
      cb(Left("no way"));
    }
  }

</pre></p><p></p><p></p><h1>Subscriptions</h1><p></p><p> There  are  two  ways  of  subscribing  to  a  channel,  sub()  and  subPkt().    </p><p></p><p> sub()  returns  the  actual  data  sent  by  the  pub()  operation,  however  that  wasn't     all  the  data  sent  over  the  wire  with  the  packet,  importantly  the  sessId  of  the     sender  is  also  available  but  obviously  you  don't  want  to  have  to  type  that  into     your  data  packet.    </p><p> Thus  subPkt()  provides  the  wire  object  Pkt  as  defined  in  Channel.hx.  Rather  than     know  the  internal  details  of  Pkt  which  may  change  it's  better  to  get  specific     information  from  the  raw  packet  by  using  some  query  function  defined  in  Channel.hx,     e.g.    </p><p><pre>Channel.sessID(pkt)</pre>   </p><p> and    </p><p><pre>Channel.chanID(pkt)</pre>   </p><p> probably  being  the  only  useful  ones  at  the  moment.    </p><p> Thus  you  are  able  to  intercept  packets  based  on  sessID,  and  do  useful  stuff.    </p><p></p><h1>Filters</h1><p></p><p> You  may  filter  packets  on  a  given  channel  by  calling  the  filter()  or  filterPkt()     methods.  These  have  the  same  semantics  as  adding  a  subscription.  With  filter()  you  are     provided  with  your  typed  data  object  with  filterPkt()  you're  provided  the  wire     object  including  sessionID  and  potentially  other  meta  data.    </p><p> The  filter  is  called  once  per  packet  before  broadcast.  Return  null  to  cancel     the  broadcast  of  the  packet.  Return  the  packet  or  a  modified  version  to     broadcast.    </p><p> For  example,    </p><p><pre>

chan.filter(function(o) {
o.nickName = o.nickName.toUpperCase();
return o;
});

    
chan.filterPkt(function(pkt) {
 trace("session id = "+Channel.sessID(pkt));
 return pkt;
});

</pre></p><p></p><p></p><h1>Meta Data</h1><p></p><p> You  can  add  meta  data  to  your  object  for  routing  and  filtering  purposes  among  others.    </p><p> To  do  so  add  a  meta  data  object  when  filling,  the  meta  data  is  stored  with  the     wire  object  and  not  with  your  data.    </p><p><pre>chan.pub(myobj,mymeta);</pre>   </p><p> to  inspect  meta  data  you  need  to  use  either  subPkt()  or  filterPkt().  Get  the     meta  data  from  the  packet  using  the  Channel.meta().    </p><p><pre>

chan.filterPkt(function(pkt) {
   var mymeta = Channel.meta(pkt);
   });
</pre></p><p></p><p> That  also  means  you  can  filter  on  meta  data.    </div>
</body>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shCore.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shBrushAS3.js"></script>    

    
    <script type="text/javascript">
      $(function() {
      $("table").addClass("gridtable");
      $("pre").addClass("brush: as3;");
      SyntaxHighlighter.highlight();
      });
    </script>
    
</html>
