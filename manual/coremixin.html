<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html"/>
      <title>Flux Framework</title>
      <link href="/reset.css" rel="stylesheet" type="text/css" />
      <link href="/content.css" rel="stylesheet" type="text/css" />
      <link href="/syntax/styles/shCore.css" rel="stylesheet" type="text/css" />
      <link href="/syntax/styles/shThemeEclipse.css" rel="stylesheet" type="text/css" />
    </head>

    <body>
      <div id="ifc">
<p></p><h1>Core</h1><p></p><p> The  Core  module  provides  some  basic  utilies  for  the  rest  of  the  system.  In     particular  it  supplies  these  types  ...    </p><p></p><table><thead><tr><th> Artifact         </th><th> Description                                                                             </th></tr></thead><tbody><tr><td> Option&lt;T&gt;        </td><td> Rid yourself of nulls. Some(t:T) or None. Mixins exist.                                 </td></tr><tr><td> Either&lt;A,B&gt;      </td><td> Dereference a Left(a:A) bad, or a Right(b:B) good. Mixins exist.                        </td></tr><tr><td> Future&lt;T&gt;        </td><td> resolve() a value and pick it up with deliver(). Create with Core.future()              </td></tr><tr><td> Outcome&lt;L,R&gt;     </td><td> A Future&lt;Either&lt;L,R&gt;&gt; with optimistic mixin sugar. Create with Core.outcome().          </td></tr><tr><td> Observable&lt;E&gt;    </td><td> notify() and observe() elements of type E. Create with Core.observable()                </td></tr><tr><td> Logging          </td><td> Core.logInit(fileName) , Core.info(msg), Core.warn(msg), Core.error(msg)                </td></tr><tr><td> Startable&lt;P,A,B&gt; </td><td> Has a start() method taking P param and returns and Outcome&lt;A,B&gt;, an asynchronous new() </td></tr><tr><td> Stoppable&lt;P,A,B&gt; </td><td> Has a stop() method taking P param and returns and Outcome&lt;A,B&gt;                         </td></tr></tbody></table><p></p><h1>Mixins</h1><p></p><p> Futures  and  most  of  the  Mixin  code  I  have  snarfed  from  Stax,  particularly     Prelude  extensions  .    </p><p> My  use  of  mixin  is  particularly  for  array  functions.  Rather  than  using  haXe's     Lambda  library  which  converts  everything  to  a  list,  the  mixin  array  functions     keep  everying  an  array,  which  is  better  for  performance.  So  for  example  by    </p><p> By  using  flux.Core  you  get  all  the  mixins,  e.g.    </p><p><pre>using flux.Core</pre>   </p><p> give  you  the  following  methods  on  array.    </p><p><pre>


  filter&lt;T&gt;(a: Array&lt;T&gt;, f: T -&gt; Bool): Array&lt;T&gt;
  size&lt;T&gt;(a: Array&lt;T&gt;): Int
  indexOf&lt;T&gt;(a: Array&lt;T&gt;, t: T): Int
  map&lt;T, S&gt;(a: Array&lt;T&gt;, f: T -&gt; S): Array&lt;S&gt;
  next&lt;T, S&gt;(a1: Array&lt;T&gt;, a2: Array&lt;S&gt;): Array&lt;S&gt;
  flatMap&lt;T, S&gt;(a: Array&lt;T&gt;, f: T -&gt; Iterable&lt;S&gt;): Array&lt;S&gt;
  foldl&lt;T, Z&gt;(a: Array&lt;T&gt;, z: Z, f: Z -&gt; T -&gt; Z): Z
  foldr&lt;T, Z&gt;(a: Array&lt;T&gt;, z: Z, f: T -&gt; Z -&gt; Z): Z
  append&lt;T&gt;(a: Array&lt;T&gt;, t: T): Array&lt;T&gt;
  snapshot&lt;T&gt;(a: Array&lt;T&gt;): Array&lt;T&gt;
  first&lt;T&gt;(a: Array&lt;T&gt;): T
  firstOption&lt;T&gt;(a: Array&lt;T&gt;): Option&lt;T&gt;
  last&lt;T&gt;(a: Array&lt;T&gt;): T
  lastOption&lt;T&gt;(a: Array&lt;T&gt;): Option&lt;T&gt;
  contains&lt;T&gt;(a: Array&lt;T&gt;, t: T): Bool
  foreach&lt;T&gt;(a: Array&lt;T&gt;, f: T -&gt; Void): Array&lt;T&gt;
  take&lt;T&gt;(a: Array&lt;T&gt;, n: Int): Array&lt;T&gt;
  takeWhile&lt;T&gt;(a: Array&lt;T&gt;, p: T -&gt; Bool): Array&lt;T&gt;
  drop&lt;T&gt;(a: Array&lt;T&gt;, n: Int): Array&lt;T&gt;
  dropWhile&lt;T&gt;(a: Array&lt;T&gt;, p: T -&gt; Bool): Array&lt;T&gt;

</pre></p><p></p><p> You  also  get  Mixins  for  bool,  int,  date  and  Outcomes    </p><p> Great  stuff,  thanks  Stax.    </p><p></p><h1>Outcome<L,R></h1><p></p><p> An  Outcome  combines  two  concepts,  Futures  and  Either,  and  is  the  primary  type  in     Flux  for  dealing  with  async  programming.  It's  defined  as    </p><p><pre>typedef Outcome&lt;L,R&gt; = Future&lt;Either&lt;L,R&gt;&gt;;</pre>   </p><p> A  Future  delivers  a  value  sometime  in  the  future  to  any  listeners  (it's  like  an     event).  An  Either  is  composed  of  two  values  a  Left  (bad)  and  a  Right  (good).    </p><p> As  a  typedef  an  Outcome  is  just  a  Future,  and  normal  Future  methods  can  be     called  on  it.  However  by    </p><p><pre>using flux.Core;</pre>   </p><p> extra  methods  are  provided  on  an  Outcome  that  ameliorate  the  unpacking  of  the     Either.  Specifically,  rather  than  receiving  an  Either  you  receive  the  result,     and  by  default,  errors  are  logged  using  the  Core.error()  method.  Error  handling     methods  may  be  added  per  call  to  customise  the  error  handling  when  required.    </p><p> For  example    </p><p><pre>

    Sys.readFile("myfile.txt").outcome(function(contents) {
           trace(contents);
       });
</pre></p><p></p><p> by  using  the  outcome()  method  you  get  the  Right  value  of  the  either  without     unpacking  it  yourself.  If  you  want  to  unpack  it  you  can  do  this  (remember  it's     just  a  Future).    </p><p><pre>

    Sys.readFile("myfile.txt").deliver(function(either) {
           switch(either) {
             case Left(err):
                 Core.error(err);
             case Right(contents):
                 trace(contents);
       });
</pre></p><p></p><p> So,  the  outcome()  method  provides  some  syntax  sugar  for  processing  the  right     result,  but  once  you  see  an  error  generated  you  may  want  to  customize  the  handing     of  it.  You  simply  add  a  second  function  to  accept  the  error.    </p><p><pre>

    Sys.readFile("myfile.txt")
      .outcome(function(contents) {
          trace(contents);
        },function(err) {
          trace(err);
      })
</pre></p><p></p><p> oflatMap()  and  omap()  methods  allow  the  chaining  of  right  values.  The  o  prefix     is  required  as  the  methods  would  otherwise  conflict  with  the  Future  methods  of     the  same  name.    </p><p> Here's  an  example:    </p><p><pre>

    Sys.writeFile("myfile.txt","my content")
      .oflatMap(function(name) {
          return Sys.rename(name,"newname.txt");
        },function(reason) {
          trace(reason);
      })
      .oflatMap(function(newName) {
          return Sys.readFile(newName);
        })
      .omap(function(contents) {
          return contents.toUpperCase();
        })
      .outcome(function(transformed) {
          trace("final text:"+transformed);
        });

</pre></p><p></p><p> Again,  each  of  the  methods,  oflatMap(),  omap()  and  outcome()  take  an  error     function  as  the  second  parameter.    </p><p> Nota  bene:  I  used  the  name  outcome()  for  the  result  rather  than,  e.g.  result(),     to  better  make  the  distiction  between  Outcome  and  it's  Future  -  because  they  are     one  in  the  same  it's  easy  to  get  confused  what  you're  dealing  with.    </p><p></p><h1>Startables/Stoppables</h1><p></p><p><pre>interface Startable&lt;P,A,B&gt;  {
  function start_(p:P,oc:Outcome&lt;A,B&gt;):Outcome&lt;A,B&gt;;
}

interface Stoppable&lt;P,A,B&gt;  {
  function stop_(p:P,oc:Outcome&lt;A,B&gt;):Outcome&lt;A,B&gt;;
}

</pre></p><p></p><p> In  an  asynchronous  world  objects  require  a  equivalent  to  new().  A  class  which     implements  Startable  provides  this  functionality.  The  Startable  interface     requires  a  function  start_()  to  be  implemented.  Starting  and  stopping  an  object     are  asynchronous  operations  and  so  are  defined  to  return  Outcomes.    </p><p> flux.Core  provides  mixins  which  allow  the  calling  of  start_()  on  the  underlying     startable  by  calling  start().  Similarly  for  Stoppables.    </p><p> The  reason  there  is  a  separate  start()  mixin  and  not  just  a  direct  call  to  a     start()  on  the  object  itself  is  that  code  is  inserted  between  the  calls  to     conveniently  create  the  return  Outcome  automatically  and  second  to  allow  "aspect"     code  be  inserted  to  determine  generically  what  objects  are  started  and     stopped.  Core.startableAspect  may  be  plugged  to  provide  an  aspect  function  -     see  Core.simpleStartableAspect()  for  an  example  which  logs  startable  objects  try  ...    </p><p><pre>

Core.startableAspect = Core.simpleStartableAspect;
</pre></p><p></p><p> By  default  Core.startableAspect  is  null.    </p><p> A  Startable  may  be  started  with  a  typed  object  parameter,  e.g.    </p><p><pre> myserver.start({port:8080,host:"localhost"})</pre>   </p><p> Even  if  you're  Startable  doesn't  need  parameters  you're  required  to  provide  an     empty  object  {}  as  a  placeholder  to  guarantee  type  checking.    </p><p> Core.stoppableAspect  exists  too.    </p><p></div>
</body>

    <script type="text/javascript" src="/jquery.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shCore.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="/syntax/scripts/shBrushAS3.js"></script>    

    
    <script type="text/javascript">
      $(function() {
      $("table").addClass("gridtable");
      $("pre").addClass("brush: as3;");
      SyntaxHighlighter.highlight();
      });
    </script>
    
</html>
